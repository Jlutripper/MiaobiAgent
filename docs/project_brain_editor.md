# 编辑器架构与交互体验

## 1. 编辑器架构：组件统一与模式控制

随着项目功能的扩展，我们对实例编辑器 (`PosterEditor`) 的架构进行了革命性的重构，以解决功能受限和代码冗余的问题。

### 1.1. 历史问题：简化的专用侧边栏 (已废弃)

-   **旧架构**: `PosterEditor` 使用一个独立的、功能被"阉割"的 `PosterEditorSidebar.tsx` 组件。
-   **缺陷**:
    -   **功能受限**: 用户无法进行高级布局调整，限制了二次创作的自由度。
    -   **代码冗余**: 任何在主检查器 `InspectorPanel` 中添加的新功能，都需要在 `PosterEditorSidebar` 中重复实现一次，导致了大量的技术债。

### 1.2. 最终解决方案："组件统一与模式控制"

我们采纳了"组件统一与模式控制" (Component Unification with Mode Control) 的先进架构。

1.  **废除简化组件**: 我们**彻底删除了** `PosterEditorSidebar.tsx`。

2.  **统一使用强大组件**: `PosterEditor` 现在直接使用与 `PosterTemplateEditor` **完全相同**的、功能强大的 **`InspectorPanel`** 和 **`LayersPanel`**。

3.  **引入 `mode` 属性进行智能控制**:
    -   `InspectorPanel` 现在拥有一个 `mode: 'template' | 'instance'` 属性。
    -   在 `'template'` 模式下（用于 `PosterTemplateEditor`），所有控件都可见。
    -   在 `'instance'` 模式下（用于 `PosterEditor`），`InspectorPanel` 会**自动地、智能地隐藏**所有与 AI 模板相关的内部字段（如 `role`, `aiInstructions`, `importance`）。

4.  **解锁用户自由**:
    -   **完全的编辑能力**: 最终用户现在拥有了微调海报的**全部**能力，包括约束布局、锚点系统、Flexbox/Grid 布局，以及所有字体和视觉效果。
    -   **完整的图层管理**: 用户可以在 `LayersPanel` 中自由地添加、删除、复制、重排、锁定和隐藏任何图层。
    -   **画布交互**: 用户现在可以自由地拖动、缩放和调整任何未被锁定的布局框。

这次架构升级将 `PosterEditor` 从一个简单的"内容填充器"转变为一个功能完善的"海报精修工具"，在给予用户最大创作自由的同时，通过 `mode` 属性保护了模板的核心知识产权，并极大地提升了代码的可维护性。

## 2. 专业级交互体验：抽象化与代码复用

### 2.1. 数值输入的优化

-   **问题**: 在应用的多个地方（检查器、区块编辑器等）都存在数值输入框。它们普遍存在一个恼人的交互问题：当用户用 Backspace 删除所有数字后，输入框会自动填入 `0`，导致下一次输入（例如 `23`）时内容变成 `023`。
-   **解决方案：自定义 Hook**: 我们没有在每个组件中重复修复这个问题，而是创建了一个**可复用的自定义 React Hook**: `hooks/useNumericInput.ts`。
    -   **核心逻辑**:
        1.  它内部维护一个字符串状态，允许输入框在编辑过程中**临时为空**。
        2.  `onChange` 事件会实时更新父组件的状态（如果输入有效），但允许本地显示为空。
        3.  **`onBlur` 事件是关键**：只有当用户离开输入框时，它才会检查内容。如果为空或无效，它会自动回退到一个安全的默认值（例如 `0`），从而保证了数据模型的完整性。
    -   **优势**: 这个 Hook 将所有复杂的输入逻辑封装起来，提供了一个极其简单的接口。现在，任何数值输入框只需使用 `const props = useNumericInput(...)` 并将 `props` 扩展到 `<input>` 上，就能立即获得专业、流畅的交互体验。这极大地提升了代码质量和用户体验的一致性。

### 2.2. 核心组件的健壮性：以图片组件为例

-   **问题**: 在 Flexbox/Grid 布局中，`<img />` 标签的 `object-fit` 属性（裁剪/完整显示）会失效。后续尝试使用绝对定位修复，又导致了在某些情况下布局坍塌、图片不显示的问题。
-   **根源**: `<img>` 标签是一种"内容决定尺寸"的元素，这与我们"结构（由 Flexbox/Grid 容器决定）优先于内容"的布局哲学相冲突。
-   **最终解决方案**: 我们重构了 `EditableImageSection.tsx` 组件，放弃了 `<img>` 标签，转而使用更稳定、更符合 Web 标准的 **CSS `background-image`** 技术。
    -   **实现**: 组件的根元素现在是一个 `<div>`。它的尺寸**完全**由父级的 Flexbox 或 Grid 布局系统决定。图片本身则作为该 `<div>` 的 `background-image` 来渲染。
    -   **优势**: 这种方式**彻底解耦**了容器尺寸和图片内容。`objectFit` 属性被完美地映射为 `background-size` (`cover`/`contain`)，同时根除了所有布局坍塌的风险。这个决策确保了图片组件在项目所有复杂的布局场景下都能正确、可靠地工作。

## 3. 状态管理与交互稳健性

### 3.1. 核心设计原则

我们在状态管理上遵循几个不可违背的原则：

1. **容器尺寸由布局系统决定，而非内容**
2. **单一真相来源 (Single Source of Truth)**
3. **事件处理的确定性**
4. **状态转换的原子性**

### 3.2. 实现细节

- **精确的事件处理**: 所有用户交互都经过严格的事件处理流程，确保状态变更的可预测性
- **可预测的编辑体验**: 通过强制重渲染、单一指令来源等技术确保编辑行为的一致性
- **数据完整性保证**: 使用 TypeScript 严格类型检查和运行时验证确保数据模型的完整性

这套架构确保了用户在使用编辑器时获得专业级的、稳定的交互体验，无论是在模板设计还是实例编辑场景下。
