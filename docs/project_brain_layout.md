# 专业级布局引擎深度剖析

这是编辑器最核心、最复杂的部分。它经历了多次重大的架构迭代，最终形成了一个功能强大、可媲美专业设计工具（如 Figma）的系统。

## 1. 布局引擎的演进历史

### 阶段一：脆弱的像素/百分比混合定位 (已废弃)
-   **问题**: 最初使用 `{ xPercent: number, yPx: number }` 进行定位。这种方式在画布宽高比变化时会完全失效，导致布局错乱。

### 阶段二：引入约束布局系统 (Constraint-Based Layout)
-   **核心**: 废弃了绝对坐标，引入了一个 `constraints` 对象，包含 `{ top, bottom, left, right, width, height }`。这些值是**字符串**（例如 `'10%'`, `'20px'`），定义了元素与其父容器之间的关系。这从根本上实现了响应式布局。

### 阶段三：引入中心点约束 (Center Constraints)
-   **核心**: 为 `constraints` 对象增加了 `centerX` 和 `centerY` 属性。
-   **技术实现**:
    -   在 `utils/layoutUtils.ts` 的 `calculateStylesFromConstraints` 函数中，我们使用 CSS `calc()` 和 `transform` 来实现精确定位。
    -   例如，`centerX: '-20px'` 会被翻译为 `left: calc(50% - 20px); transform: translateX(-50%);`，确保元素中心相对于父容器中心进行偏移。

### 阶段四：引入双模内容布局引擎 (Flexbox + Grid)
-   **核心**: 认识到 Flexbox 在处理二维布局上的局限性，我们为 `LayoutBox` 引入了 `layoutMode: 'flex' | 'grid'` 属性。
-   **`flex` 模式 (默认)**: 用于在一维（行或列）上对齐内部元素，适用于大多数内容块。
-   **`grid` 模式**: 用于强大的二维布局。当一个容器被设为 `grid` 模式时，我们可以为其定义 `gridTemplateColumns` 和 `gridTemplateRows`。其子元素的位置将由新增的 `gridColumn` 和 `gridRow` 属性决定，**忽略**它们自身的 `constraints`。

### 阶段五：引入双模定位引擎 (Constraint vs. Anchor)
-   **核心**: 为了实现元素与元素之间（同级）的相对定位，我们为 `LayoutBox` 和 `DecorationElement` 引入了锚定 (`anchor`) 功能。一个元素现在可以拥有两种定位模式：
    -   **约束模式 (默认)**: 相对于**父容器**定位。
    -   **锚定模式**: 相对于**同级元素**定位。

## 2. 设计师体验的革命：从数据到意图

### 阶段一：可视化约束控件 (已废弃)
-   **尝试**: 我们曾实现了一个类似 Figma 的九宫格可视化控件，让用户点击线条来添加/移除约束。
-   **问题**: 虽然比纯文本输入好，但对于复杂约束的组合，其交互状态仍然会变得混乱，对非专业用户不够友好。

### 阶段二：文本化、分组化的智能对齐按钮 (最终方案)
-   **核心理念**: 我们意识到，设计师思考的是**"意图"**（例如"让它水平居中"），而不是"约束的组合"。
-   **实现 (`InspectorPanel.tsx`)**:
    -   **UI 变革**: 彻底移除了所有抽象图标和可视化控件。取而代之的是带有**明确中文标签**的按钮组："水平对齐"（左、中、右、拉伸）、"垂直对齐"（上、中、下、拉伸）和一个独立的"画布居中"。
    -   **智能逻辑 (关键！)**: 这些按钮背后是智能的。例如，点击"水平居中"会触发以下操作：
        1.  **自动清理**: 移除任何与之冲突的约束（`left` 和 `right`）。
        2.  **尺寸保护**: 检查元素是否定义了 `width`。如果未定义，会自动添加一个默认值（例如 `'50%'`）。
        3.  **应用约束**: 添加 `centerX: '0px'`。
    -   这个"基于意图"的设计，从根本上解决了之前所有的居中 Bug 和交互混乱问题。
-   **中心点偏移**: 当一个元素被居中后，检查器会智能地显示**"水平偏移 (X)"**和**"垂直偏移 (Y)"**的输入框，允许设计师进行精确的微调。

### 阶段三：可视化 Grid 构建器 (最终方案)
-   **核心理念**: 同样基于"意图"的设计，我们用一个模块化的构建器取代了手写 CSS 字符串的 `grid-template-columns` 输入框。
-   **实现 (`InspectorPanel.tsx`)**:
    -   **UI 变革**: 用户现在可以通过点击 `[+ 列]` 和 `[+ 行]` 按钮来动态地添加/删除网格轨道。
    -   **模块化控制**: 每一行/列的大小和单位 (`fr`, `px`, `%`, `auto`) 都可以通过独立的控件进行设置。
    -   **精细间距**: 提供了独立的"列间距"和"行间距"输入框。

## 3. 固定画布

与所有专业设计工具一样，我们最终采用了**固定画布**模型。`PosterTemplate` 的 `height` 属性现在是**必需的**，这废除了早期不可预测的"画布自动增长"行为，为约束系统提供了稳定、可靠的计算基础。

## 4. 锚定系统 (Anchor System) 深度剖析

锚定系统为设计师提供了从严格的父子约束中"逃逸"出来的能力，实现了元素间的精确定位。其核心是两种附着模式：

### 内部附着模式 (`attachmentMode: 'inside'`)
-   **设计意图**: 将被锚定元素**置于**目标元素的内部，使其自身的某个点与目标的对应点对齐。
-   **计算逻辑**:
    -   首先，在目标元素上找到**锚点**（例如，`top-center` 是其顶边中点）。
    -   然后，在被锚定元素自身上找到**附着点**（例如，`top-center` 是其自身的顶边中点）。
    -   最后，通过平移，使**附着点**与**锚点**重合。
-   **结果**: `top-center` 锚定会使两个元素的顶边中点完美对齐。

### 外部附着模式 (`attachmentMode: 'outside'`)
-   **设计意图**: 将被锚定元素**置于**目标元素的外部，使其自身的某个点与目标的对应点对齐，从而产生"推开"的效果。
-   **计算逻辑 (关键！)**:
    -   首先，在目标元素上找到**锚点**（例如，`top-left` 是其左上角）。
    -   然后，在被锚定元素自身上找到**逻辑上的对侧点**作为**附着点**。
    -   最后，通过平移，使**附着点**与**锚点**重合。
-   **示例**:
    -   当锚定到目标的**左上角 (`top-left`)** 时，附着点是自身的**右下角**。这会将元素完美地"推"到目标的左上角之外。
    -   当锚定到目标的**中上 (`top-center`)** 时，附着点是自身的**中下边缘**。这会将元素完美地"推"到目标的正上方。
-   这个"对侧附着"的逻辑，完全符合设计师的直觉，并确保了所有 8 个边缘和角落锚点的行为都精确无误。

## 5. 渲染引擎的统一："单一真相来源"原则的最终实现

在开发过程中，我们遇到了一个极其棘手且反复出现的 Bug：在聊天窗口中预览的海报布局与在编辑器中打开的布局不一致。

-   **问题根源**: `PosterPreview.tsx` (预览组件) 和 `Editable...` (编辑器组件) 各自实现了一套独立的、未能完全同步的布局计算逻辑，导致了渲染时机和计算上的细微差异，引发了竞态条件 (Race Condition)，尤其是在图片加载和锚点计算上。

-   **最终解决方案："编辑器级离屏快照"架构**: 我们遵循了软件工程的黄金法则：**单一真相来源 (Single Source of Truth)**，并采用了绝对可靠的生产级方案。
    1.  **废除"仿制品"**: 我们**彻底删除了 `components/PosterPreview.tsx`**。它是所有不一致问题的根源，必须从项目中移除。
    2.  **创建权威的快照工具**: 我们在 `components/chat/results/PosterResult.tsx` 中创建了一个全新的、权威的工具函数：**`createPosterSnapshot`**。
    3.  **使用"真相"进行渲染**: 这个函数的核心是，它在屏幕外（`left: -9999px`）的一个临时 `div` 中，使用与编辑器**完全相同**的 `Editable...` 系列组件来渲染海报。这保证了渲染逻辑的绝对统一。
    4.  **消除竞态条件**: 该函数被设计为**确定性的**。它会智能地收集海报中的所有图片URL，并使用 `Promise.all` **等待所有图片都 100% 加载完成**。然后，它会再等待一个浏览器渲染帧 (`requestAnimationFrame`)，确保所有样式都已应用。**只有在这之后**，它才会调用 `html2canvas` 进行快照。
    5.  **统一快照入口**:
        -   在 `App.tsx` 中，当AI生成海报后，调用 `createPosterSnapshot` 生成低分辨率预览图，并存入 `result.previewImageUrl`。
        -   在 `PosterResult.tsx` 中，当用户点击"导出"时，**再次调用同一个函数**，生成高分辨率图片。
-   **结果**: 这次重构从根本上解决了所有"所见即所得"的问题，确保了从预览、编辑到最终导出的所有环节，视觉表现 **100% 一致**。

-   **编辑器导出的最终方案："原始尺寸克隆"快照法**:
    -   **问题**: `html2canvas` 在处理一个已经被 CSS `transform: scale()` 缩放过的元素时，其内部计算会变得不可靠。
    -   **解决方案**: 编辑器（`PosterEditor.tsx` 和 `LongArticleEditor.tsx`）的导出功能现在采用了一种媲美专业工具（如Figma）的健壮方法：
        1.  使用 `useRef` 获取用户在屏幕上看到的、**已被缩放的**画布。
        2.  在点击导出的瞬间，使用 `element.cloneNode(true)` 创建一个该画布的**完整深度克隆**。
        3.  对克隆体进行**"净化"**：强制移除其 `transform` 样式，并将其 `width` 和 `height` 设置为模板的**原始、未经缩放**的尺寸。
        4.  将这个"纯净的克隆体"添加到屏幕外的不可见区域。
        5.  让 `html2canvas` 去快照这个纯净的、标准的、未经任何变换的元素。
        6.  快照完成后，立即从 DOM 中移除这个克隆体。
    -   这个方案消除了所有不确定性，保证了导出的图片与编辑器中所见的 **100% 像素级一致**。

## 6. 稳健的文本编辑与渲染：最终架构

在处理富文本编辑器（特别是 `contentEditable` 属性）时，我们遇到了两个核心的顽固 Bug："幽灵文字"（退出编辑模式后，旧的文本内容在画布左上角残留）和"内容无法保存"。这促使我们对 `EditableTextSection.tsx` 及其交互逻辑进行了彻底的重构，最终形成了一套极其稳健的架构。

### 问题根源分析
1.  **渲染冲突**: "幽灵文字"的根本原因是 **React 的协调 (Reconciliation) 机制与浏览器原生 `contentEditable` 状态管理之间的深层次冲突**。当编辑状态切换时，React 可能会尝试"复用"DOM 节点而不是彻底销毁它，导致浏览器管理的、半销毁的节点被遗留在屏幕上。
2.  **事件竞争**: "内容无法保存"的根本原因是**事件竞争条件 (Event Race Condition)**。外部元素的 `onClick` 事件（例如点击画布）比文本框自身的 `onBlur`（保存）事件更快地被处理，导致父组件在"保存"逻辑有机会执行前就销毁了文本框。
3.  **解析脆弱性**: 最初的 `htmlToSpans` 解析器无法处理浏览器在用户编辑时产生的"脏"HTML（例如用 `<div>` 而不是 `<br>` 来换行），导致解析失败并返回空内容。

### 最终解决方案
1.  **强制重渲染 (`key` 属性)**: 这是解决渲染冲突的"核武器"。通过为编辑模式和显示模式下的根元素赋予不同的 `key` (`<div key="editor">` vs `<div key="display">`)，我们强制 React 在模式切换时**彻底销毁旧的 DOM 树并从零开始创建一个全新的**。这从根本上杜绝了任何 DOM 节点残留的可能性。
2.  **单一指令来源 (`onBlur`)**: 我们重构了事件处理逻辑，确立了一个核心原则：**只有文本框自身的 `onBlur` 事件才能触发退出编辑模式**。`onBlur` 事件现在被设计为可靠地先执行"保存内容"，然后再触发"退出编辑"。所有外部的 `onClick` 事件不再干涉编辑状态，从而彻底消除了事件竞争。
3.  **递归 DOM 树解析器**: 我们用一个全新的、基于**递归树遍历**的 `htmlToSpans` 函数替换了旧的解析器。这个新解析器能够像浏览器一样，逐一分析 `contentEditable` 区域内的每一个 DOM 节点（包括 `<span>`, `<div>`, `<br>`, 纯文本节点等），智能地识别换行和继承样式，从而稳健地将任何复杂的、由浏览器生成的 HTML 结构准确地转换回我们干净的 `TextSpan[]` 数据格式。
4.  **渲染器统一原则**: 为了确保视觉上的"所见即所得"，我们遵循一个简单的原则：对于没有"弯曲"效果的常规文本，**显示模式使用一个标准的、不可编辑的 `<div>` 来渲染**。因为它与编辑模式下的 `contentEditable <div>` 使用完全相同的 CSS 盒模型，所以它们的高度和换行行为将 **100% 一致**。仅当文本应用了"弯曲"效果时，组件才会智能地切换到 **SVG 渲染引擎**。

## 7. 高级文本效果：稳健的文字弯曲

### 问题根源
简单的 CSS `transform` 无法实现真正的文字弯曲效果；它只会扭曲整个元素的矩形"盒子"，而不会让文字本身沿着路径"流动"。更严重的是，它不会改变元素的布局尺寸，导致弯曲后的文字与其他元素发生重叠。

### 最终解决方案：SVG 渲染引擎
我们在 `EditableTextSection.tsx` 中实现了一个专业的 SVG 渲染器来彻底解决这个问题。
1.  **动态路径生成**: 当用户调整 `curve` 属性时，系统会动态计算出一条 SVG 弧形路径 (`<path>`) 的几何数据。
2.  **文本路径附着**: 使用 SVG 的 `<textPath>` 元素，将文本内容精确地附着在这条路径上，实现平滑、自然的弯曲效果。
3.  **精确边界框测量 (核心！)**: 在每次渲染后，我们使用 `useLayoutEffect` Hook 和浏览器的底层 `getBBox()` API 来**精确测量渲染后的 SVG 文本的实际像素边界框 (Bounding Box)**。
4.  **无缝布局集成**: 系统会**立即将这个测量出的高度应用到文本区块的父容器上**。这个动态设置的高度值，会被父容器的 Flexbox 或 Grid 布局系统正确地识别和计算，从而确保整个海报布局会像流水一样自适应调整，完美地容纳弯曲的文字，**从根本上杜绝了任何重叠或错位的 Bug**。
5.  **智能渲染切换**: 该组件会智能地判断 `curve` 值。如果 `curve` 为 `0`，它会自动切换回性能更高、更标准的 HTML 渲染器；只有当 `curve` 非零时，它才会启用 SVG 渲染引擎。

## 8. 文本旋转与布局优先架构：稳健的视觉效果实现

在实现文本旋转功能时，我们遇到了两个核心的架构冲突：**旋转导致容器尺寸变化引发布局问题**和**垂直文本高度异常**。这促使我们重新审视并强化了"布局优先于内容"的核心设计原则。

### 问题根源分析
1.  **架构原则违反**: 初始的旋转实现尝试让文本内容决定容器尺寸，这直接违反了系统的核心架构原则：**容器尺寸由父级 LayoutBox 的 Flexbox/Grid 约束系统决定，而非内容**。
2.  **布局系统冲突**: 动态计算旋转后的边界框并调整容器尺寸，会破坏整个海报的布局流，导致其他元素位置发生不可预测的变化。
3.  **垂直文本处理不当**: 垂直文本 (`writingMode: 'vertical-rl'`) 在没有宽度限制的情况下会产生异常高的容器，破坏视觉平衡。
4.  **React Hook 规则违反**: 条件性的 `useMemo` 调用违反了 React Hook 的调用顺序规则，导致运行时错误。

### 最终解决方案：布局优先的旋转架构
1.  **容器尺寸不变原则**: 文本组件的容器始终保持 `width: '100%'` 和 `height: '100%'`，完全由父级 LayoutBox 决定。这确保了布局系统的稳定性和可预测性。
2.  **纯视觉旋转效果**: 旋转通过 CSS `transform: rotate()` 实现，仅作为视觉效果，不影响布局流。使用 `transform-origin: center center` 确保围绕中心旋转。
3.  **溢出可见策略**: 使用 `overflow: visible` 确保旋转后的内容可见，但不改变父容器的布局计算。
4.  **垂直文本约束**: 为垂直文本设置 `maxWidth: '200px'`，防止过高的容器，同时允许自然的文字换行。
5.  **Hook 调用顺序修复**: 将所有 Hook 调用移至组件顶部，确保符合 React Hook 规则，避免条件性的早期返回。

### 架构一致性保证
1.  **责任分离**: TextSection 负责文本渲染和视觉效果，LayoutBox 负责布局约束和空间分配。
2.  **AI Agent 兼容**: 更新了 `posterAgentService.ts` 和 `visualDeconstructorService.ts` 的 System Prompt，包含文本旋转和垂直文本的生成指导。
3.  **Schema 一致性**: 确保 `rotation` 属性在缩放处理中被正确处理（旋转角度不需要缩放）。
4.  **编辑体验统一**: 编辑模式和显示模式都应用相同的文本约束，确保"所见即所得"的编辑体验。
