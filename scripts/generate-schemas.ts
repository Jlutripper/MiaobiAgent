import { Project, ts, Type, Symbol, InterfaceDeclaration, TypeAliasDeclaration, Node } from 'ts-morph';
import { Type as GeminiType } from '@google/genai';
import * as fs from 'fs';
import * as path from 'path';

class TypeConverter {
    private sourceFile: any;
    private processingStack: string[] = [];

    constructor(sourceFile: any) {
        this.sourceFile = sourceFile;
    }

    private convert(type: Type): any {
        if (this.isCircular(type)) {
            return { type: GeminiType.OBJECT, description: "Recursive structure" };
        }

        if (type.isString() || type.isStringLiteral()) return { type: GeminiType.STRING };
        if (type.isNumber() || type.isNumberLiteral()) return { type: GeminiType.NUMBER };
        if (type.isBoolean() || type.isBooleanLiteral()) return { type: GeminiType.BOOLEAN };

        if (type.isArray()) {
            return {
                type: GeminiType.ARRAY,
                items: this.convert(type.getArrayElementTypeOrThrow())
            };
        }

        if (type.isUnion()) {
            const unionTypes = type.getUnionTypes();
            if (unionTypes.every(t => t.isStringLiteral())) {
                return {
                    type: GeminiType.STRING,
                    enum: unionTypes.map(t => t.getLiteralValueOrThrow() as string)
                };
            }
            // For complex unions (like ArticleSection), we create a generic object
            // as Gemini schema doesn't support oneOf/anyOf for different object shapes.
            // The AI prompt must guide the model on what specific shape to use.
            if (unionTypes.some(t => t.isObject())) {
                return { type: GeminiType.OBJECT, description: "Could be one of multiple object types." };
            }
            return this.convert(unionTypes[0]); // Fallback for simple unions
        }

        if (type.isObject()) {
            const schema: any = { type: GeminiType.OBJECT, properties: {}, required: [] };
            const properties = type.getProperties();

            this.processingStack.push(this.getTypeName(type));

            for (const prop of properties) {
                const propName = prop.getName();
                const decl = prop.getDeclarations()[0];
                const propType = decl.getType();
                const propSchema = this.convert(propType);

                const comment = this.getJsDocComment(prop);
                if (comment) propSchema.description = comment;

                schema.properties[propName] = propSchema;
                if (!prop.isOptional()) {
                    schema.required.push(propName);
                }
            }
            if (schema.required.length === 0) delete schema.required;

            this.processingStack.pop();
            return schema;
        }

        return { type: GeminiType.STRING, description: `Unsupported type: ${type.getText()}` };
    }

    private getTypeName(type: Type): string {
        const symbol = type.getAliasSymbol() || type.getSymbol();
        return symbol ? symbol.getName() : 'anonymous';
    }

    private isCircular(type: Type): boolean {
        return this.processingStack.includes(this.getTypeName(type));
    }

    private getJsDocComment(symbol: Symbol): string | null {
        const decl = symbol.getDeclarations()[0];
        if (decl && Node.isPropertySignature(decl) && decl.getJsDocs().length > 0) {
            return decl.getJsDocs()[0].getDescription().trim();
        }
        return null;
    }


    public generateSchemas(typeNames: string[]): string {
        let output = `// This file is auto-generated by scripts/generate-schemas.ts
// Do not edit this file manually.

import { Type as GeminiType } from '@google/genai';

`;
        for (const typeName of typeNames) {
            const typeAliasOrInterface = this.sourceFile.getInterface(typeName) || this.sourceFile.getTypeAlias(typeName);
            if (typeAliasOrInterface) {
                this.processingStack = []; // Reset stack for each top-level type
                const schema = this.convert(typeAliasOrInterface.getType());
                const schemaName = typeName.charAt(0).toLowerCase() + typeName.slice(1) + 'Schema';
                output += `export const ${schemaName} = ${JSON.stringify(schema, null, 2).replace(/"(GeminiType\.\w+)"/g, '$1')};\n\n`;
            } else {
                console.warn(`Type "${typeName}" not found in source file.`);
            }
        }
        return output;
    }
}

try {
    const project = new Project();
    const sourceFile = project.addSourceFileAtPath('types.ts');
    const converter = new TypeConverter(sourceFile);

    const typeNamesToGenerate = [
        'TextSpan',
        'TextSection',
        'ImageSection',
        'LayoutBox',
    ];

    const generatedCode = converter.generateSchemas(typeNamesToGenerate);
    const outputPath = path.resolve(__dirname, '../services/generatedSchemas.ts');
    fs.writeFileSync(outputPath, generatedCode);

    console.log(`✅ Schemas generated successfully at: ${outputPath}`);
} catch (error) {
    console.error("❌ Failed to generate schemas:", error);
    throw error;
}
