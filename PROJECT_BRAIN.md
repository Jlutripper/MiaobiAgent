# 🧠 AI 创意助手: 项目大脑 & RAG 知识库

本文档是 AI 创意助手项目的核心技术与设计知识库，旨在作为项目的“记忆核心”。它为人类开发者和 AI 辅助系统（作为 RAG 库）提供了一个详尽的、唯一的真相来源，记录了从项目启动至今的所有关键决策、架构演进和实现细节。

---

## 1. 核心哲学与愿景

### 1.1. 项目设计宗旨：AI-First 三大核心原则

我们的项目基于三个不可动摇的核心宗旨，这些原则深深印记在每一行代码、每一个架构决策中：

#### 🎨 **Design with AI (与AI共同设计)**
**理念**: AI不是工具，而是我们的设计合作伙伴。我们的系统让AI参与到创意过程的每一个环节。

**实现体现**:
- **动态模板生成**: `generateDynamicTemplate()` 让AI成为专业的布    -   **最终收益**: 这个架构升级从根本上消除了"功能-提示词漂移"的问题。开发者现在可以放心地在 `types.ts` 中修改数据结构，构建系统会自动保证所有 AI Agent 的"知识"同步更新，确保    -   `InspectorPanel` 现在拥有一个 `mode: 'template' | 'instance'` 属性。
    -   在 `'template'` 模式下（用于 `PosterTemplateEditor`），所有控件都可见。
    -   在 `'instance'` 模式下（用于 `PosterEditor`），`InspectorPanel` 会**自动地、智能地隐藏**所有与 AI 模板相关的内部字段（如 `role`, `aiInstructions`, `importance`）。

4.  **解锁用户自由**:
    -   **完全的编辑能力**: 最终用户现在拥有了微调海报的**全部**能力，包括约束布局、锚点系统、Flexbox/Grid 布局，以及所有字体和视觉效果。
    -   **完整的图层管理**: 用户可以在 `LayersPanel` 中自由地添加、删除、复制、重排、锁定和隐藏任何图层。
    -   **画布交互**: 用户现在可以自由地拖动、缩放和调整任何未被锁定的布局框。

这次架构升级将 `PosterEditor` 从一个简单的"内容填充器"转变为一个功能完善的"海报精修工具"，在给予用户最大创作自由的同时，通过 `mode` 属性保护了模板的核心知识产权，并极大地提升了代码的可维护性。

---

## 8. 内网环境适配与结构优化

随着项目在不同环境中的部署需求增加，我们对系统架构进行了全面的内网化改造和结构优化，以支持在无外部网络连接的环境中完全运行。

### 8.1. 内网环境适配：外部依赖的彻底本地化

#### 8.1.1. 历史问题与挑战

-   **外部资源依赖**: 
    -   **字体资源**: 项目最初完全依赖 Google Fonts CDN 提供的 Noto Sans SC 和 ZCOOL KuaiLe 字体。
    -   **CSS 框架**: 通过 CDN 加载 Tailwind CSS (`https://cdn.tailwindcss.com`)，这在无外网环境中无法访问。
    -   **字体声明**: CSS 中的 `@font-face` 规则指向外部 CDN 地址。

-   **业务需求**: 
    -   应用需要部署在公司内部网络环境中，这些环境通常被防火墙隔离，无法访问外部资源。
    -   保持设计一致性，即使在内网环境中也需要相同的字体和样式表现。

#### 8.1.2. 内网化改造方案

我们采用了全面的内网化改造策略，确保所有外部依赖都被替换为本地资源：

1.  **字体本地化**:
    -   **资源迁移**: 将所有必要的字体文件 (`.ttf`) 下载并存储在 `/public/assets/fonts/` 目录下。
    -   **CSS 重构**: 创建本地字体 CSS 文件 (`fonts.css`)，使用相对路径引用本地字体文件。
    -   **一致性保障**: 确保所有字体权重 (400, 700, 900) 都有对应的本地文件，保持与原设计完全一致。

2.  **Tailwind CSS 本地化**:
    -   **构建流程优化**: 使用 npm 安装 Tailwind CSS、PostCSS 和 Autoprefixer 作为本地开发依赖。
    -   **配置文件创建**: 生成 `tailwind.config.js` 和 `postcss.config.js` 配置文件，以支持本地构建。
    -   **构建脚本添加**: 在 `package.json` 中添加 `build:css` 脚本，在每次构建前自动生成优化后的 CSS。

3.  **HTML 结构更新**:
    -   **移除外部引用**: 删除所有指向外部 CDN 的 `<link>` 和 `<script>` 标签。
    -   **添加本地资源**: 更新 HTML 以引用本地托管的字体和 CSS 文件。
    -   **结构优化**: 简化 HTML 结构，提高加载性能。

#### 8.1.3. 技术实现示例

```html
<!-- 旧版 index.html (依赖外部资源) -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700;900&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
<script src="https://cdn.tailwindcss.com"></script>

<!-- 新版 index.html (完全本地化) -->
<link rel="stylesheet" href="/assets/fonts/fonts.css">
<link rel="stylesheet" href="/assets/css/main.css">
```

```css
/* 本地化字体定义 (fonts.css) */
@font-face {
  font-family: 'Noto Sans SC';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url('./noto-sans-sc-400.ttf') format('truetype');
}

@font-face {
  font-family: 'ZCOOL KuaiLe';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url('./zcool-kuaile-400.ttf') format('truetype');
}
```

```javascript
// tailwind.config.js 配置
export default {
  content: [
    "./index.html",
    "./components/**/*.{js,ts,jsx,tsx}",
    "./App.tsx",
    "./index.tsx",
    "./src/**/*.{js,ts,jsx,tsx}"
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ['"Noto Sans SC"', 'sans-serif'],
        cursive: ['"ZCOOL KuaiLe"', 'cursive'],
      }
    },
  },
  plugins: [],
}
```

### 8.2. 项目结构优化：标准化与可维护性提升

随着内网化改造，我们同时对整个项目结构进行了全面优化，使其更符合现代前端项目的最佳实践。

#### 8.2.1. 结构优化核心目标

-   **标准化目录结构**: 建立符合行业标准的目录组织方式，提高新开发者的上手效率。
-   **关注点分离**: 明确划分代码、样式和资源文件的职责，避免混淆。
-   **构建流程优化**: 简化并规范化构建流程，确保一致的输出结果。
-   **冗余文件清理**: 移除不再使用的临时文件和重复配置。

#### 8.2.2. 具体优化措施

1.  **CSS 文件整合与重组**:
    -   创建专门的 `src/styles` 目录，集中管理所有样式源文件。
    -   将样式逻辑分离为主样式文件 (`main.css`) 和自定义样式 (`custom.css`)。
    -   构建后的 CSS 统一放置在 `public/assets/css` 目录，遵循资源管理最佳实践。

2.  **资源目录标准化**:
    -   在 `public/assets` 下创建清晰的子目录结构：`css`、`fonts` 等。
    -   确保所有资源文件都有明确的归属和组织逻辑。
    -   统一资源引用路径，提高可维护性。

3.  **构建配置优化**:
    -   更新 `package.json` 中的构建脚本，包含新的 CSS 构建流程。
    -   优化 Tailwind 配置，确保精确匹配项目所需的内容。
    -   简化 Vite 配置，提高构建性能。

4.  **冗余清理**:
    -   移除根目录中的临时 CSS 文件。
    -   删除不再使用的 CDN 引用和配置。
    -   合并重复的样式定义，减少代码量。

#### 8.2.3. 最终成果与收益

这次结构优化带来了显著的改进：

-   **部署灵活性**: 项目现在可以无缝部署在任何环境中，无论是否有外部网络连接。
-   **加载性能提升**: 本地资源加载减少了网络请求，提高了应用启动速度。
-   **维护性提高**: 标准化的目录结构和清晰的关注点分离，大幅降低了维护难度。
-   **一致的视觉体验**: 确保在任何环境中都能获得完全相同的字体和样式表现。
-   **构建可靠性**: 改进的构建流程减少了环境差异带来的问题，提高了部署成功率。

这次内网化改造和结构优化是对项目架构的重要补充，进一步体现了我们对不同部署环境的适应性和对代码质量的追求。它为项目的长期维护和未来扩展奠定了更加坚实的基础。可维护性。

### 4.6. MCP服务集成：专业工具的无缝接入

为了提供真正专业级的功能（如背景移除、图像处理等），我们集成了 **Model Context Protocol (MCP)** 支持，实现与本地专业服务的无缝对接。

-   **架构设计**: 
    -   **MCPAdapter**: 专门的适配器，实现与MCP服务的标准化通信
    -   **统一接口**: 通过 `unifiedAIService.callMCPService()` 提供统一的调用入口
    -   **配置驱动**: 支持环境变量配置，便于不同环境的部署和切换

-   **背景移除服务重构**:
    -   **移除AI假抠图**: 彻底废除了之前的"AI重新生成"伪背景移除方案
    -   **真正专业处理**: 通过MCP调用真正的背景移除算法（AI模型、传统算法或混合方案）
    -   **高级选项支持**: 支持边缘平滑、透明度保留、质量控制等专业功能
    -   **批量处理**: 提供批量背景移除功能，支持进度回调和错误处理

-   **可扩展架构**:
    -   **工具无关**: MCP适配器可以轻松扩展支持更多工具（图像超分辨率、色彩校正等）
    -   **服务发现**: 自动检测和配置可用的MCP服务
    -   **故障恢复**: 提供清晰的错误信息和配置指导

-   **集成示例**:
    ```typescript
    // 调用MCP背景移除服务
    const result = await removeImageBackground(imageData, {
        method: 'ai_model',
        quality: 'high',
        edgeSmoothing: true,
        preserveTransparency: true
    });
    ```

这个架构升级体现了我们**AI-First**宗旨中的**"Design for AI"**原则：不仅AI能够理解和操作我们的系统，外部专业工具也能通过标准化接口无缝集成，形成强大的AI+专业工具生态。建筑师，基于约束系统创建结构化设计
- **智能内容适配**: AI理解并遵循我们的Grid/Flexbox双模布局引擎    -   **代码冗余**: 任何在主检查器 `InspectorPanel` 中添加的新功能，都需要在 `PosterEditorSidebar` 中重复实现一次，导致了大量的技术债。

### 7.2. 最终解决方案："组件统一与模式控制"

我们采纳了"组件统一与模式控制" (Component Unification with Mode Control) 的先进架构。级的响应式设计
- **协作式工作流**: 双Agent架构（布局师+内容师）实现AI内部的专业分工协作

#### 🔧 **Design for AI (为AI而设计)**
**理念**: 我们的架构、数据结构、接口都优先考虑AI的理解能力和操作便利性。

**实现体现**:
- **类型即真相**: `types.ts` 作为唯一数据契约来源，自动生成AI Schema，杜绝功能-提示词漂移
- **AI元数据系统**: `importance`, `aiInstructions`, `isContentLocked` 为AI提供精确的操作指导
- **原子化Schema设计**: `layoutBoxSchema`, `textSpanSchema` 等可组合式设计，让AI能够精确理解和操作每个组件
- **约束完整性规则**: 专为AI设计的布局约束规则，确保AI生成的布局在任何情况下都是有效的

#### 🚀 **AI-First (AI优先架构)**
**理念**: 整个系统架构以AI能力为中心设计，确保AI能力的无限扩展性。

**实现体现**:
- **专家Agent生态**: 每个领域都有专门的AI专家（海报、长图文、图像处理、视觉解构），可无限扩展
- **适配器模式**: 支持多AI服务商的可插拔架构，轻松集成新的AI能力
- **Agent编排中心**: `App.tsx` 统一调度所有AI能力，实现复杂的AI工作流编排
- **AI操作抽象**: 所有复杂操作都被抽象为AI可理解的高级指令，为未来的"AI掌控编辑器"奠定基础

**终极愿景**: 
我们正在构建一个真正的"AI设计师助手"生态系统，而非简单的"内容生成器"。我们的目标是让AI能够：
- 理解用户的设计意图
- 独立操作专业级编辑器
- 生成可完全编辑的结构化设计
- 与人类设计师无缝协作

这一愿景将彻底超越业界主流的"直接图片生成"方案，提供真正适合生产环境的、可持续迭代的设计解决方案。

### 1.2. 项目目标

构建一个先进的、对话式的、可扩展的创意内容生成平台。用户通过自然语言与 AI 互动，完成从海报设计到图像处理等一系列复杂任务。核心是提供一个既智能易用，又具备专业级微调能力的强大工具。

### 1.3. 架构演进：从"上帝对象"到"专家 Agent 工作流"

项目初期，所有 AI 逻辑都集中在一个单一的服务文件中。这很快被证明是不可持续的，因为它违反了**单一职责原则**，导致了高耦合、低可测试性和差的可扩展性。

我们果断地进行了重构，采用了**“专家 Agent 工作流 (Specialist Agent Workflow)”**的核心架构理念。

-   **理念**: 将复杂的 AI 任务分解为由多个职责单一的“专家 Agent”协同完成的流水线。每个 Agent 只做一件事，并把它做到极致。
-   **优势**:
    -   **模块化**: 每个功能（海报、长图文、图像工具）都是一个独立的服务。
    -   **可测试性**: 可以独立测试每个 Agent 的功能。
    -   **可扩展性**: 添加新功能只需创建一个新的 Agent 服务，并在路由器中“注册”即可。
    -   **AI 性能**: 更小、更专注的 Prompt 会带来更稳定、更准确、更快的 AI 响应。

---

## 2. 系统架构深度剖析

### 2.1. 前端技术栈

-   **框架**: React 19 (使用 Hooks 和函数式组件)
-   **语言**: TypeScript (强制严格类型检查)
-   **样式**: Tailwind CSS (用于快速的、实用程序优先的 UI 开发)
-   **本地存储**: `idb` (IndexedDB 的一个轻量级封装，用于持久化用户数据)
-   **AI SDK**: `openai`
-   **构建工具**: Vite (高效的前端构建工具)
-   **CSS 处理**: PostCSS + Autoprefixer (用于现代化CSS处理)
-   **字体**: 本地托管的 Noto Sans SC 和 ZCOOL KuaiLe 字体文件

### 2.2. 数据持久化

我们使用 **IndexedDB** 而不是 `localStorage`，因为它为存储复杂的 JavaScript 对象（如模板）提供了更强大和高效的解决方案。

-   **`services/dbService.ts`**: 提供了与 `idb` 库交互的底层、类型安全的封装。
-   **`hooks/useIndexedDBStore.ts`**: 一个自定义的 React Hook，它抽象了从 IndexedDB 加载数据和将状态变更同步回数据库的逻辑，为组件提供了类似于 `useState` 的简单接口。
 
### 2.3. 前端组件专家模式

与后端的“专家 Agent”理念相呼应，前端也遵循了类似的“专家组件”模式。

-   **历史问题**: 最初，`ResultCard.tsx` 是一个“上帝组件”，它包含了渲染所有不同类型AI结果（海报、长图文、图片）的 `switch` 逻辑，以及所有相关的操作（导出、编辑、下载）函数。这严重违反了单一职责和开闭原则，导致组件难以维护和扩展。
-   **最终方案**: 我们将 `ResultCard.tsx` 重构为一个纯粹的“调度器”。它唯一的职责就是根据 `result.type` 来渲染对应的“专家组件”。所有具体的渲染和逻辑都被下放到了各自的专家组件中：
    -   `components/chat/results/PosterResult.tsx`
    -   `components/chat/results/LongArticleResult.tsx`
    -   `components/chat/results/ImageResult.tsx`
-   **优势**: 这种架构使得添加新的结果类型变得极其简单，只需创建一个新的专家组件并在调度器中增加一个 `case` 即可，完全无需修改任何现有组件的逻辑。

### 2.4. 多服务商 AI 架构：从抽象层到适配器模式的终极进化

为了实现极致的灵活性、原子化和可扩展性，我们对AI服务层进行了一次决定性的架构重构，从一个简单的**抽象层**进化到了一个真正**可插拔**的**适配器设计模式 (Adapter Pattern)**。

#### 历史问题：条件分支的“坏味道”

最初的 `unifiedAIService.ts` 虽然实现了逻辑上的解耦，但其内部依赖于一个巨大的 `if/else` 逻辑块来区分不同的 `provider`。这种设计存在明显的“代码坏味道”：每当需要支持一个新的AI服务商（例如 Claude），我们就必须修改这个核心文件，增加一个新的 `else if` 分支。这违反了**开闭原则**，随着服务商的增多，文件会变得越来越臃肿，难以维护。

#### 最终方案：适配器模式 (The Adapter Pattern)

新架构将AI服务层彻底重构为一个由多个独立、原子化的“适配器”组成的系统，由一个轻量级的“路由器”进行调度。

-   **`services/adapters/AIAdapter.ts` (设计合同)**:
    -   **职责**: 定义了一个 TypeScript `interface`，作为所有AI服务商适配器都必须遵守的“通用合同”。它规定了所有适配器都必须实现 `generateJSON`, `generateImage` 等标准方法。

-   **`services/adapters/openaiAdapter.ts` (专家翻译官)**:
    -   **职责**: 每个文件都是一个实现了 `AIAdapter` 接口的具体类。它们各自**完全封装**了与特定服务商SDK通信的所有细节。
    -   **例如**: `openaiAdapter` 知道如何使用 `response_format: { type: "json_object" }` 以及如何将我们的 `schema` 翻译成文本指令。

-   **`services/aiClient.ts` (中央控制面板 & 适配器注册表)**:
    -   **职责**: 其角色被提升了。它不仅是**模型配置中心**（通过 `AI_MODELS` 对象），现在还是**适配器注册表**。它负责实例化所有可用的适配器 (`new GeminiAdapter()`, `new OpenAIAdapter()`) 并将它们存储在一个全局可访问的映射中。

-   **`services/unifiedAIService.ts` (轻量级路由器)**:
    -   **职责**: 这个文件被极大地简化了。它现在是一个**纯粹的路由器**，不再包含任何 `if/else` 服务商逻辑。
    -   **工作流程**: 当一个Agent调用它时，它会：
        1.  根据任务类型，从 `aiClient.ts` 的 `AI_MODELS` 中查找 `provider`。
        2.  使用 `provider` 名称，从 `aiClient.ts` 的适配器注册表中获取对应的**适配器实例**。
        3.  调用该适配器的相应方法，将任务完全委托出去。

#### 新架构的巨大优势

-   **真正的可插拔性**: 要支持一个新的AI服务商（如 Claude），我们现在**只需**在 `adapters` 目录下创建一个新的 `claudeAdapter.ts` 文件，实现 `AIAdapter` 接口，然后在 `aiClient.ts` 中注册它即可。**`unifiedAIService.ts` 的核心逻辑再也无需被修改**。
-   **高内聚，低耦合**: 与OpenAI相关的代码只存在于`openaiAdapter.ts`中。这使得代码库极其清晰、原子化，并且易于维护和独立测试。
-   **极致的灵活性**: 开发者现在可以通过修改**唯一的配置文件** `aiClient.ts` 来为任何任务精确地指派任何已注册的AI服务商，实现了前所未有的控制力。

---

## 3. 专业级布局引擎深度剖析

这是编辑器最核心、最复杂的部分。它经历了多次重大的架构迭代，最终形成了一个功能强大、可媲美专业设计工具（如 Figma）的系统。

### 3.1. 布局引擎的演进历史

1.  **阶段一：脆弱的像素/百分比混合定位 (已废弃)**
    -   **问题**: 最初使用 `{ xPercent: number, yPx: number }` 进行定位。这种方式在画布宽高比变化时会完全失效，导致布局错乱。

2.  **阶段二：引入约束布局系统 (Constraint-Based Layout)**
    -   **核心**: 废弃了绝对坐标，引入了一个 `constraints` 对象，包含 `{ top, bottom, left, right, width, height }`。这些值是**字符串**（例如 `'10%'`, `'20px'`），定义了元素与其父容器之间的关系。这从根本上实现了响应式布局。

3.  **阶段三：引入中心点约束 (Center Constraints)**
    -   **核心**: 为 `constraints` 对象增加了 `centerX` 和 `centerY` 属性。
    -   **技术实现**:
        -   在 `utils/layoutUtils.ts` 的 `calculateStylesFromConstraints` 函数中，我们使用 CSS `calc()` 和 `transform` 来实现精确定位。
        -   例如，`centerX: '-20px'` 会被翻译为 `left: calc(50% - 20px); transform: translateX(-50%);`，确保元素中心相对于父容器中心进行偏移。

4.  **阶段四：引入双模内容布局引擎 (Flexbox + Grid)**
    -   **核心**: 认识到 Flexbox 在处理二维布局上的局限性，我们为 `LayoutBox` 引入了 `layoutMode: 'flex' | 'grid'` 属性。
    -   **`flex` 模式 (默认)**: 用于在一维（行或列）上对齐内部元素，适用于大多数内容块。
    -   **`grid` 模式**: 用于强大的二维布局。当一个容器被设为 `grid` 模式时，我们可以为其定义 `gridTemplateColumns` 和 `gridTemplateRows`。其子元素的位置将由新增的 `gridColumn` 和 `gridRow` 属性决定，**忽略**它们自身的 `constraints`。

5.  **阶段五：引入双模定位引擎 (Constraint vs. Anchor)**
    -   **核心**: 为了实现元素与元素之间（同级）的相对定位，我们为 `LayoutBox` 和 `DecorationElement` 引入了锚定 (`anchor`) 功能。一个元素现在可以拥有两种定位模式：
        -   **约束模式 (默认)**: 相对于**父容器**定位。
        -   **锚定模式**: 相对于**同级元素**定位。

### 3.2. 设计师体验的革命：从数据到意图

1.  **阶段一：可视化约束控件 (已废弃)**
    -   **尝试**: 我们曾实现了一个类似 Figma 的九宫格可视化控件，让用户点击线条来添加/移除约束。
    -   **问题**: 虽然比纯文本输入好，但对于复杂约束的组合，其交互状态仍然会变得混乱，对非专业用户不够友好。

2.  **阶段二：文本化、分组化的智能对齐按钮 (最终方案)**
    -   **核心理念**: 我们意识到，设计师思考的是**“意图”**（例如“让它水平居中”），而不是“约束的组合”。
    -   **实现 (`InspectorPanel.tsx`)**:
        -   **UI 变革**: 彻底移除了所有抽象图标和可视化控件。取而代之的是带有**明确中文标签**的按钮组：“水平对齐”（左、中、右、拉伸）、“垂直对齐”（上、中、下、拉伸）和一个独立的“画布居中”。
        -   **智能逻辑 (关键！)**: 这些按钮背后是智能的。例如，点击“水平居中”会触发以下操作：
            1.  **自动清理**: 移除任何与之冲突的约束（`left` 和 `right`）。
            2.  **尺寸保护**: 检查元素是否定义了 `width`。如果未定义，会自动添加一个默认值（例如 `'50%'`）。
            3.  **应用约束**: 添加 `centerX: '0px'`。
        -   这个“基于意图”的设计，从根本上解决了之前所有的居中 Bug 和交互混乱问题。
    -   **中心点偏移**: 当一个元素被居中后，检查器会智能地显示**“水平偏移 (X)”**和**“垂直偏移 (Y)”**的输入框，允许设计师进行精确的微调。

3.  **阶段三：可视化 Grid 构建器 (最终方案)**
    -   **核心理念**: 同样基于“意图”的设计，我们用一个模块化的构建器取代了手写 CSS 字符串的 `grid-template-columns` 输入框。
    -   **实现 (`InspectorPanel.tsx`)**:
        -   **UI 变革**: 用户现在可以通过点击 `[+ 列]` 和 `[+ 行]` 按钮来动态地添加/删除网格轨道。
        -   **模块化控制**: 每一行/列的大小和单位 (`fr`, `px`, `%`, `auto`) 都可以通过独立的控件进行设置。
        -   **精细间距**: 提供了独立的“列间距”和“行间距”输入框。

### 3.3. 固定画布

与所有专业设计工具一样，我们最终采用了**固定画布**模型。`PosterTemplate` 的 `height` 属性现在是**必需的**，这废除了早期不可预测的“画布自动增长”行为，为约束系统提供了稳定、可靠的计算基础。

### 3.4. 锚定系统 (Anchor System) 深度剖析

锚定系统为设计师提供了从严格的父子约束中“逃逸”出来的能力，实现了元素间的精确定位。其核心是两种附着模式：

-   **内部附着模式 (`attachmentMode: 'inside'`)**:
    -   **设计意图**: 将被锚定元素**置于**目标元素的内部，使其自身的某个点与目标的对应点对齐。
    -   **计算逻辑**:
        -   首先，在目标元素上找到**锚点**（例如，`top-center` 是其顶边中点）。
        -   然后，在被锚定元素自身上找到**附着点**（例如，`top-center` 是其自身的顶边中点）。
        -   最后，通过平移，使**附着点**与**锚点**重合。
    -   **结果**: `top-center` 锚定会使两个元素的顶边中点完美对齐。

-   **外部附着模式 (`attachmentMode: 'outside'`)**:
    -   **设计意图**: 将被锚定元素**置于**目标元素的外部，使其自身的某个点与目标的对应点对齐，从而产生“推开”的效果。
    -   **计算逻辑 (关键！)**:
        -   首先，在目标元素上找到**锚点**（例如，`top-left` 是其左上角）。
        -   然后，在被锚定元素自身上找到**逻辑上的对侧点**作为**附着点**。
        -   最后，通过平移，使**附着点**与**锚点**重合。
    -   **示例**:
        -   当锚定到目标的**左上角 (`top-left`)** 时，附着点是自身的**右下角**。这会将元素完美地“推”到目标的左上角之外。
        -   当锚定到目标的**中上 (`top-center`)** 时，附着点是自身的**中下边缘**。这会将元素完美地“推”到目标的正上方。
    -   这个“对侧附着”的逻辑，完全符合设计师的直觉，并确保了所有 8 个边缘和角落锚点的行为都精确无误。

### 3.5. 渲染引擎的统一：“单一真相来源”原则的最终实现

在开发过程中，我们遇到了一个极其棘手且反复出现的 Bug：在聊天窗口中预览的海报布局与在编辑器中打开的布局不一致。

-   **问题根源**: `PosterPreview.tsx` (预览组件) 和 `Editable...` (编辑器组件) 各自实现了一套独立的、未能完全同步的布局计算逻辑，导致了渲染时机和计算上的细微差异，引发了竞态条件 (Race Condition)，尤其是在图片加载和锚点计算上。

-   **最终解决方案：“编辑器级离屏快照”架构**: 我们遵循了软件工程的黄金法则：**单一真相来源 (Single Source of Truth)**，并采用了绝对可靠的生产级方案。
    1.  **废除“仿制品”**: 我们**彻底删除了 `components/PosterPreview.tsx`**。它是所有不一致问题的根源，必须从项目中移除。
    2.  **创建权威的快照工具**: 我们在 `components/chat/results/PosterResult.tsx` 中创建了一个全新的、权威的工具函数：**`createPosterSnapshot`**。
    3.  **使用“真相”进行渲染**: 这个函数的核心是，它在屏幕外（`left: -9999px`）的一个临时 `div` 中，使用与编辑器**完全相同**的 `Editable...` 系列组件来渲染海报。这保证了渲染逻辑的绝对统一。
    4.  **消除竞态条件**: 该函数被设计为**确定性的**。它会智能地收集海报中的所有图片URL，并使用 `Promise.all` **等待所有图片都 100% 加载完成**。然后，它会再等待一个浏览器渲染帧 (`requestAnimationFrame`)，确保所有样式都已应用。**只有在这之后**，它才会调用 `html2canvas` 进行快照。
    5.  **统一快照入口**:
        -   在 `App.tsx` 中，当AI生成海报后，调用 `createPosterSnapshot` 生成低分辨率预览图，并存入 `result.previewImageUrl`。
        -   在 `PosterResult.tsx` 中，当用户点击“导出”时，**再次调用同一个函数**，生成高分辨率图片。
-   **结果**: 这次重构从根本上解决了所有“所见即所得”的问题，确保了从预览、编辑到最终导出的所有环节，视觉表现 **100% 一致**。

-   **编辑器导出的最终方案：“原始尺寸克隆”快照法**:
    -   **问题**: `html2canvas` 在处理一个已经被 CSS `transform: scale()` 缩放过的元素时，其内部计算会变得不可靠。
    -   **解决方案**: 编辑器（`PosterEditor.tsx` 和 `LongArticleEditor.tsx`）的导出功能现在采用了一种媲美专业工具（如Figma）的健壮方法：
        1.  使用 `useRef` 获取用户在屏幕上看到的、**已被缩放的**画布。
        2.  在点击导出的瞬间，使用 `element.cloneNode(true)` 创建一个该画布的**完整深度克隆**。
        3.  对克隆体进行**“净化”**：强制移除其 `transform` 样式，并将其 `width` 和 `height` 设置为模板的**原始、未经缩放**的尺寸。
        4.  将这个“纯净的克隆体”添加到屏幕外的不可见区域。
        5.  让 `html2canvas` 去快照这个纯净的、标准的、未经任何变换的元素。
        6.  快照完成后，立即从 DOM 中移除这个克隆体。
    -   这个方案消除了所有不确定性，保证了导出的图片与编辑器中所见的 **100% 像素级一致**。

### 3.6. 稳健的文本编辑与渲染：最终架构

在处理富文本编辑器（特别是 `contentEditable` 属性）时，我们遇到了两个核心的顽固 Bug：“幽灵文字”（退出编辑模式后，旧的文本内容在画布左上角残留）和“内容无法保存”。这促使我们对 `EditableTextSection.tsx` 及其交互逻辑进行了彻底的重构，最终形成了一套极其稳健的架构。

-   **问题根源分析**:
    1.  **渲染冲突**: “幽灵文字”的根本原因是 **React 的协调 (Reconciliation) 机制与浏览器原生 `contentEditable` 状态管理之间的深层次冲突**。当编辑状态切换时，React 可能会尝试“复用”DOM 节点而不是彻底销毁它，导致浏览器管理的、半销毁的节点被遗留在屏幕上。
    2.  **事件竞争**: “内容无法保存”的根本原因是**事件竞争条件 (Event Race Condition)**。外部元素的 `onClick` 事件（例如点击画布）比文本框自身的 `onBlur`（保存）事件更快地被处理，导致父组件在“保存”逻辑有机会执行前就销毁了文本框。
    3.  **解析脆弱性**: 最初的 `htmlToSpans` 解析器无法处理浏览器在用户编辑时产生的“脏”HTML（例如用 `<div>` 而不是 `<br>` 来换行），导致解析失败并返回空内容。

-   **最终解决方案**:
    1.  **强制重渲染 (`key` 属性)**: 这是解决渲染冲突的“核武器”。通过为编辑模式和显示模式下的根元素赋予不同的 `key` (`<div key="editor">` vs `<div key="display">`)，我们强制 React 在模式切换时**彻底销毁旧的 DOM 树并从零开始创建一个全新的**。这从根本上杜绝了任何 DOM 节点残留的可能性。
    2.  **单一指令来源 (`onBlur`)**: 我们重构了事件处理逻辑，确立了一个核心原则：**只有文本框自身的 `onBlur` 事件才能触发退出编辑模式**。`onBlur` 事件现在被设计为可靠地先执行“保存内容”，然后再触发“退出编辑”。所有外部的 `onClick` 事件不再干涉编辑状态，从而彻底消除了事件竞争。
    3.  **递归 DOM 树解析器**: 我们用一个全新的、基于**递归树遍历**的 `htmlToSpans` 函数替换了旧的解析器。这个新解析器能够像浏览器一样，逐一分析 `contentEditable` 区域内的每一个 DOM 节点（包括 `<span>`, `<div>`, `<br>`, 纯文本节点等），智能地识别换行和继承样式，从而稳健地将任何复杂的、由浏览器生成的 HTML 结构准确地转换回我们干净的 `TextSpan[]` 数据格式。
    4.  **渲染器统一原则**: 为了确保视觉上的“所见即所得”，我们遵循一个简单的原则：对于没有“弯曲”效果的常规文本，**显示模式使用一个标准的、不可编辑的 `<div>` 来渲染**。因为它与编辑模式下的 `contentEditable <div>` 使用完全相同的 CSS 盒模型，所以它们的高度和换行行为将 **100% 一致**。仅当文本应用了“弯曲”效果时，组件才会智能地切换到 **SVG 渲染引擎**。

### 3.7. 文本旋转与布局优先架构：稳健的视觉效果实现

在实现文本旋转功能时，我们遇到了两个核心的架构冲突：**旋转导致容器尺寸变化引发布局问题**和**垂直文本高度异常**。这促使我们重新审视并强化了"布局优先于内容"的核心设计原则。

-   **问题根源分析**:
    1.  **架构原则违反**: 初始的旋转实现尝试让文本内容决定容器尺寸，这直接违反了系统的核心架构原则：**容器尺寸由父级 LayoutBox 的 Flexbox/Grid 约束系统决定，而非内容**。
    2.  **布局系统冲突**: 动态计算旋转后的边界框并调整容器尺寸，会破坏整个海报的布局流，导致其他元素位置发生不可预测的变化。
    3.  **垂直文本处理不当**: 垂直文本 (`writingMode: 'vertical-rl'`) 在没有宽度限制的情况下会产生异常高的容器，破坏视觉平衡。
    4.  **React Hook 规则违反**: 条件性的 `useMemo` 调用违反了 React Hook 的调用顺序规则，导致运行时错误。

-   **最终解决方案：布局优先的旋转架构**:
    1.  **容器尺寸不变原则**: 文本组件的容器始终保持 `width: '100%'` 和 `height: '100%'`，完全由父级 LayoutBox 决定。这确保了布局系统的稳定性和可预测性。
    2.  **纯视觉旋转效果**: 旋转通过 CSS `transform: rotate()` 实现，仅作为视觉效果，不影响布局流。使用 `transform-origin: center center` 确保围绕中心旋转。
    3.  **溢出可见策略**: 使用 `overflow: visible` 确保旋转后的内容可见，但不改变父容器的布局计算。
    4.  **垂直文本约束**: 为垂直文本设置 `maxWidth: '200px'`，防止过高的容器，同时允许自然的文字换行。
    5.  **Hook 调用顺序修复**: 将所有 Hook 调用移至组件顶部，确保符合 React Hook 规则，避免条件性的早期返回。

-   **架构一致性保证**:
    1.  **责任分离**: TextSection 负责文本渲染和视觉效果，LayoutBox 负责布局约束和空间分配。
    2.  **AI Agent 兼容**: 更新了 `posterAgentService.ts` 和 `visualDeconstructorService.ts` 的 System Prompt，包含文本旋转和垂直文本的生成指导。
    3.  **Schema 一致性**: 确保 `rotation` 属性在缩放处理中被正确处理（旋转角度不需要缩放）。
    4.  **编辑体验统一**: 编辑模式和显示模式都应用相同的文本约束，确保"所见即所得"的编辑体验。

### 3.8. 高级文本效果：稳健的文字弯曲

-   **问题根源**: 简单的 CSS `transform` 无法实现真正的文字弯曲效果；它只会扭曲整个元素的矩形“盒子”，而不会让文字本身沿着路径“流动”。更严重的是，它不会改变元素的布局尺寸，导致弯曲后的文字与其他元素发生重叠。

-   **最终解决方案：SVG 渲染引擎**: 我们在 `EditableTextSection.tsx` 中实现了一个专业的 SVG 渲染器来彻底解决这个问题。
    1.  **动态路径生成**: 当用户调整 `curve` 属性时，系统会动态计算出一条 SVG 弧形路径 (`<path>`) 的几何数据。
    2.  **文本路径附着**: 使用 SVG 的 `<textPath>` 元素，将文本内容精确地附着在这条路径上，实现平滑、自然的弯曲效果。
    3.  **精确边界框测量 (核心！)**: 在每次渲染后，我们使用 `useLayoutEffect` Hook 和浏览器的底层 `getBBox()` API 来**精确测量渲染后的 SVG 文本的实际像素边界框 (Bounding Box)**。
    4.  **无缝布局集成**: 系统会**立即将这个测量出的高度应用到文本区块的父容器上**。这个动态设置的高度值，会被父容器的 Flexbox 或 Grid 布局系统正确地识别和计算，从而确保整个海报布局会像流水一样自适应调整，完美地容纳弯曲的文字，**从根本上杜绝了任何重叠或错位的 Bug**。
    5.  **智能渲染切换**: 该组件会智能地判断 `curve` 值。如果 `curve` 为 `0`，它会自动切换回性能更高、更标准的 HTML 渲染器；只有当 `curve` 非零时，它才会启用 SVG 渲染引擎。

### 3.8. 高级文本效果：稳健的文字弯曲

-   **问题根源**: 简单的 CSS `transform` 无法实现真正的文字弯曲效果；它只会扭曲整个元素的矩形"盒子"，而不会让文字本身沿着路径"流动"。更严重的是，它不会改变元素的布局尺寸，导致弯曲后的文字与其他元素发生重叠。

-   **最终解决方案：SVG 渲染引擎**: 我们在 `EditableTextSection.tsx` 中实现了一个专业的 SVG 渲染器来彻底解决这个问题。
    1.  **动态路径生成**: 当用户调整 `curve` 属性时，系统会动态计算出一条 SVG 弧形路径 (`<path>`) 的几何数据。
    2.  **文本路径附着**: 使用 SVG 的 `<textPath>` 元素，将文本内容精确地附着在这条路径上，实现平滑、自然的弯曲效果。
    3.  **精确边界框测量 (核心！)**: 在每次渲染后，我们使用 `useLayoutEffect` Hook 和浏览器的底层 `getBBox()` API 来**精确测量渲染后的 SVG 文本的实际像素边界框 (Bounding Box)**。
    4.  **无缝布局集成**: 系统会**立即将这个测量出的高度应用到文本区块的父容器上**。这个动态设置的高度值，会被父容器的 Flexbox 或 Grid 布局系统正确地识别和计算，从而确保整个海报布局会像流水一样自适应调整，完美地容纳弯曲的文字，**从根本上杜绝了任何重叠或错位的 Bug**。
    5.  **智能渲染切换**: 该组件会智能地判断 `curve` 值。如果 `curve` 为 `0`，它会自动切换回性能更高、更标准的 HTML 渲染器；只有当 `curve` 非零时，它才会启用 SVG 渲染引擎。

### 3.9. 专业级交互体验：抽象化与代码复用

-   **问题**: 在应用的多个地方（检查器、区块编辑器等）都存在数值输入框。它们普遍存在一个恼人的交互问题：当用户用 Backspace 删除所有数字后，输入框会自动填入 `0`，导致下一次输入（例如 `23`）时内容变成 `023`。
-   **解决方案：自定义 Hook**: 我们没有在每个组件中重复修复这个问题，而是创建了一个**可复用的自定义 React Hook**: `hooks/useNumericInput.ts`。
    -   **核心逻辑**:
        1.  它内部维护一个字符串状态，允许输入框在编辑过程中**临时为空**。
        2.  `onChange` 事件会实时更新父组件的状态（如果输入有效），但允许本地显示为空。
        3.  **`onBlur` 事件是关键**：只有当用户离开输入框时，它才会检查内容。如果为空或无效，它会自动回退到一个安全的默认值（例如 `0`），从而保证了数据模型的完整性。
    -   **优势**: 这个 Hook 将所有复杂的输入逻辑封装起来，提供了一个极其简单的接口。现在，任何数值输入框只需使用 `const props = useNumericInput(...)` 并将 `props` 扩展到 `<input>` 上，就能立即获得专业、流畅的交互体验。这极大地提升了代码质量和用户体验的一致性。

### 3.10. 核心组件的健壮性：以图片组件为例

-   **问题**: 在 Flexbox/Grid 布局中，`<img />` 标签的 `object-fit` 属性（裁剪/完整显示）会失效。后续尝试使用绝对定位修复，又导致了在某些情况下布局坍塌、图片不显示的问题。
-   **根源**: `<img>` 标签是一种“内容决定尺寸”的元素，这与我们“结构（由 Flexbox/Grid 容器决定）优先于内容”的布局哲学相冲突。
-   **最终解决方案**: 我们重构了 `EditableImageSection.tsx` 组件，放弃了 `<img>` 标签，转而使用更稳定、更符合 Web 标准的 **CSS `background-image`** 技术。
    -   **实现**: 组件的根元素现在是一个 `<div>`。它的尺寸**完全**由父级的 Flexbox 或 Grid 布局系统决定。图片本身则作为该 `<div>` 的 `background-image` 来渲染。
    -   **优势**: 这种方式**彻底解耦**了容器尺寸和图片内容。`objectFit` 属性被完美地映射为 `background-size` (`cover`/`contain`)，同时根除了所有布局坍塌的风险。这个决策确保了图片组件在项目所有复杂的布局场景下都能正确、可靠地工作。

---

## 4. AI Agent 工作流深度剖析

应用程序的智能核心被分解为多个“专家 Agent”服务，由 `App.tsx` 进行编排。

### 4.1. `chatRouterService.ts` (意图路由器)

-   **职责**: 接收用户的原始消息，并将其转换为一个结构化的 JSON 指令。
-   **Prompt**: 它的系统指令包含了所有可用工具和模板的描述。它被严格指示去进行**语义分析**来选择最合适的工具和模板，并在没有强匹配时**必须回退**到 `templateId: 'none'`。
-   **输出**: `{ tool, templateId, prompt, reply, ... }`

### 4.2. `App.tsx` (总指挥/编排器)

-   **职责**: `processMessage` 函数接收来自路由器的 JSON，并像一个项目经理一样，将任务分派给相应的专家服务。

### 4.3. `visualDeconstructorService.ts` (AI 布局解构专家)

这是我们“从图片导入模板”功能的核心。它采用了比单 Agent 更优越的**双 Agent 工作流**。

-   **Agent A: AI 视觉分析师 (`analyzeImageContent`)**:
    -   **职责**: 一个纯粹的计算机视觉系统。它的**唯一**任务是分析图片，并生成一个高级的、语义化的**视觉大纲** (一个中间 JSON 格式)。它**不知道也不关心**我们最终的 `PosterTemplate` 格式。
    -   **优势**: 专注使其更准确。它不会因生成复杂的技术性 JSON 而分心，从而能更可靠地识别背景和元素。

-   **Agent B: AI 模板架构师 (`buildTemplateFromAnalysis`)**:
    -   **职责**: 一个纯粹的技术架构师。它**从未见过原始图片**。它的**唯一**任务是接收 Agent A 生成的视觉大纲，并将其“翻译”成我们系统所需的、技术上完全正确的 `PosterTemplate` JSON。
    -   **优势**: 分离关注点。它只专注于技术实现，确保了输出的模板结构稳固、符合所有约束规则。

这个双 Agent 架构从根本上解决了单 Agent 方案中常见的逻辑混乱、无法识别背景等问题。

### 4.4. `posterAgentService.ts` (海报设计专家)

这是最复杂的 Agent，它内部包含一个**两步工作流**，并经过了多次智能化升级。

-   **第一步：AI 布局建筑师 (`generateDynamicTemplate`)**:
    -   **触发**: 当 `templateId` 为 `'none'` 时被调用。
    -   **Prompt**: 它的系统指令极其专业和严格。它被告知：
        -   自己是一个使用**约束和网格布局**的专业设计师。
        -   **必须**遵循“约束完整性规则”（例如，`centerX` 必须与 `width` 配对）。
        -   **严禁**生成任何内容（`sections` 数组必须为空）。
    -   **输出**: 一个高质量的、无内容的、临时的 `PosterTemplate` 结构。

-   **第二步：AI 内容填充师 (`generatePosterLayout`)**:
    -   **输入**: 接收一个模板（无论是预设的还是动态生成的）和用户的请求。
    -   **Prompt**: 它的系统指令是“室内设计师”。它被告知：
        -   **必须**在给定的“蓝图”（模板结构）内工作。
        -   **黄金法则**: 如果一个 `LayoutBox` 是空的，**必须**根据其 `role` 为其创造新的、合适的 `TextSection` 或 `ImageSection`。
        -   **语言规则**: 生成的文本**必须**是中文，图片 prompt **必须**是英文。
    -   **智能化升级 1: 智能模板适配与缩放**:
        -   **问题**: 当一个为大尺寸设计的模板被应用到小尺寸画布时，模板内的字体、边距等固定像素值并未按比例缩小。
        -   **解决方案**: `posterAgentService.ts` 现在会计算一个精确的 `scaleFactor` (缩放因子)，并递归地遍历整个模板结构，将**所有**基于像素 (`px`) 的样式（如 `fontSize`, `padding`, `borderRadius`, `gap` 以及约束中的像素值）按比例缩放，同时保持百分比值不变。
    -   **智能化升级 2: 绝对的样式保真度**:
        -   **问题**: 模板中设置的样式（特别是富文本颜色）在 AI 生成内容后会丢失。
        -   **解决方案**: 我们重构了 AI Agent 的核心逻辑，从“信任 AI”转变为**“强制执行规则”**。
            1.  **强制保留 `style` 对象**: 当填充一个模板中已存在的区块时，程序会**完全丢弃** AI 可能返回的任何 `style` 对象，并**强制性地重新应用原始模板中的 `style` 对象**。
            2.  **智能替换富文本**: 程序不再用纯文本粗暴地覆盖 HTML。而是通过在内存中创建一个 DOM 元素，**只替换其 `textContent`**，从而完美保留所有格式标签（如 `<font color="...">`）。

### 4.5. AI Agent 维护与健壮性：从纪律到架构的飞跃

-   **核心挑战：“功能-提示词漂移 (Feature-Prompt Drift)”**
    -   **定义**: 当应用程序的前端组件或核心数据结构 (`types.ts`) 升级后（例如，为 `ImageSection` 添加了 `blur` 属性），依赖这些结构的 AI Agent 的系统指令 (System Prompt) 和 JSON Schema 却没有被**手动**同步更新。这会导致 AI 仍然按照“旧图纸”生成不兼容的“老零件”，引发运行时错误。
    -   **结论**: 单纯依赖开发者“记住要去更新”是不可靠的，必须通过架构来解决。

-   **最终解决方案：“类型即真相”与自动 Schema 生成管线**
    -   **核心理念**: 我们建立了一个架构级保障，确立了 **`types.ts` 作为定义 AI 数据契约的唯一真相来源 (Single Source of Truth)**。
    -   **实现 (`scripts/generate-schemas.ts`)**:
        1.  **自动解析**: 我们创建了一个构建脚本，使用 `ts-morph` 库来程序化地读取和解析 `types.ts` 文件的抽象语法树 (AST)。
    2.  **自动编译**: 该脚本能够将指定的 TypeScript 接口（如 `LayoutBox`, `TextSection`）**自动编译**成我们内部通用的 JSON Schema（轻量格式）。
        3.  **无缝集成**: 这个脚本被集成到了 `dev` 和 `build` 命令中。这意味着，**每一次启动或构建项目时，Schema 都会被自动重新生成**并输出到 `services/generatedSchemas.ts`。
        4.  **架构重构**: 所有的 Agent 服务（如 `posterAgentService.ts`）都被重构，不再包含任何手写的、巨大的 Schema 对象。取而代之的是，它们直接 `import` 并使用这些**永远保持最新**的、自动生成的 Schema。
    -   **最终收益**: 这个架构升级从根本上消除了“功能-提示词漂移”的问题。开发者现在可以放心地在 `types.ts` 中修改数据结构，构建系统会自动保证所有 AI Agent 的“知识”同步更新，确保了系统的长期健壮性和可维护性。

---

## 5. AI-First 开发纪律与最佳实践

### 5.1. 神圣不可违背的开发原则

#### 🎯 **Agent-First 重构清单 (强制执行)**
**理念**: 每当一个开发者要修改一个被 AI 依赖的组件时，他们必须遵循一个严格的清单。

**清单步骤**:
1. **识别消费者**: "我要修改 `EditableImageSection.tsx`。哪些 AI Agent 会消费它生成的数据结构？" 
   → 答案：`visualDeconstructorService` 和 `posterAgentService`。

2. **更新生产者 (Agent)**: "我必须立刻去这两个服务里，检查并更新它们的 System Prompt 和 Schema，以匹配我的新改动。"

3. **更新文档**: "我必须更新 `PROJECT_BRAIN.md` 中关于图片组件的部分。"

4. **验证AI理解**: "我必须测试相关AI Agent，确保它们能正确理解和使用新的数据结构。"

#### 📖 **PROJECT_BRAIN.md 的核心地位 (神圣法则)**
**规则**: 任何对核心组件或类型的重大修改，其 Pull Request 都必须包含对 `PROJECT_BRAIN.md` 相应部分的更新。这份文档是我们对 AI 和对未来开发者沟通的"API 文档"，必须保持最新。

#### 🔄 **Design with AI, Design for AI, AI-First 原则检查**
**每次代码变更前的自检清单**:
- ✅ **Design with AI**: 这个改动是否提升了AI的创作能力？
- ✅ **Design for AI**: 这个改动是否让AI更容易理解和操作？
- ✅ **AI-First**: 这个改动是否优先考虑了AI的扩展性？

### 5.2. 架构进化路径

我们的最终目标是实现**"AI掌控编辑器"**的完整生态，当前架构已经为此奠定了95%的基础。剩余的5%进化路径：

1. **AI操作指令系统**: 让AI能生成精确的编辑器操作指令
2. **AI视觉反馈循环**: 让AI能"看到"编辑结果并持续优化
3. **对话式编辑界面**: "帮我把标题移到右上角"式的自然语言编辑
4. **AI设计师助手**: 真正的AI设计合作伙伴，而非工具

---

## 6. 如何扩展应用

该应用程序为轻松扩展而设计。

### 6.1. 添加一个新的预定义工具

1.  **定义工具类型**: 在 `types.ts` 中，将新工具的 ID 添加到 `PredefinedTool` 类型。
2.  **注册工具**: 在 `constants.ts` 中，将新工具的条目添加到 `PREDEFINED_TOOLS` 数组。这会使其自动被 `chatRouterService` 识别。
3.  **实现 Agent 服务**: 创建一个新的 `services/newToolAgentService.ts` 文件。在该文件中，为你的工具创建一个 `async` 函数，该函数接受必要的参数，并使用专门为该任务设计的 Prompt 和 Schema 调用 `unifiedAIService`。
4.  **在编排器中路由**: 在 `App.tsx` 的 `executeInteraction` 函数中，为你的新工具 ID 在 `if/else` 语句中添加一个分支，并调用你在新服务文件中创建的函数。
5.  **渲染结果**: 在 `components/chat/ResultCard.tsx` 中添加逻辑来渲染新工具的输出。
6.  **遵循AI-First原则**: 确保新工具符合我们的三大核心宗旨，为AI协作而优化设计。

---

## 7. 编辑器架构: 组件统一与模式控制

随着项目功能的扩展，我们对实例编辑器 (`PosterEditor`) 的架构进行了革命性的重构，以解决功能受限和代码冗余的问题。

### 7.1. 历史问题：简化的专用侧边栏 (已废弃)

-   **旧架构**: `PosterEditor` 使用一个独立的、功能被“阉割”的 `PosterEditorSidebar.tsx` 组件。
-   **缺陷**:
    -   **功能受限**: 用户无法进行高级布局调整，限制了二次创作的自由度。
    -   **代码冗余**: 任何在主检查器 `InspectorPanel` 中添加的新功能，都需要在 `PosterEditorSidebar` 中重复实现一次，导致了大量的技术债。

### 6.2. 最终解决方案：“组件统一与模式控制”

我们采纳了“组件统一与模式控制” (Component Unification with Mode Control) 的先进架构。

1.  **废除简化组件**: 我们**彻底删除了** `PosterEditorSidebar.tsx`。

2.  **统一使用强大组件**: `PosterEditor` 现在直接使用与 `PosterTemplateEditor` **完全相同**的、功能强大的 **`InspectorPanel`** 和 **`LayersPanel`**。

3.  **引入 `mode` 属性进行智能控制**:
    -   `InspectorPanel` 现在拥有一个 `mode: 'template' | 'instance'` 属性。
    -   在 `'template'` 模式下（用于 `PosterTemplateEditor`），所有控件都可见。
    -   在 `'instance'` 模式下（用于 `PosterEditor`），`InspectorPanel` 会**自动地、智能地隐藏**所有与 AI 模板相关的内部字段（如 `role`, `aiInstructions`, `importance`）。

4.  **解锁用户自由**:
    -   **完全的编辑能力**: 最终用户现在拥有了微调海报的**全部**能力，包括约束布局、锚点系统、Flexbox/Grid 布局，以及所有字体和视觉效果。
    -   **完整的图层管理**: 用户可以在 `LayersPanel` 中自由地添加、删除、复制、重排、锁定和隐藏任何图层。
    -   **画布交互**: 用户现在可以自由地拖动、缩放和调整任何未被锁定的布局框。

这次架构升级将 `PosterEditor` 从一个简单的“内容填充器”转变为一个功能完善的“海报精修工具”，在给予用户最大创作自由的同时，通过 `mode` 属性保护了模板的核心知识产权，并极大地提升了代码的可维护性。